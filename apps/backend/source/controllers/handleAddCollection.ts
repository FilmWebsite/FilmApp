import fs from 'fs';
import path, { dirname } from 'path';
import { fileURLToPath } from 'url';
import { pool } from '@film/postgres-api';
import { Collection } from '@film/photos-iso';

export const runMigration = async (migration: string) => {
  try {
    const client = await pool.connect();

    await client.query(migration);
    client.release();
  } catch (error) {
    // Handle the error appropriately, you can log it or throw a custom error
    console.log(error);
    throw new Error('Error updating migration table');
  }
};

export const updateMigrationTable = async (name: string) => {
  try {
    const client = await pool.connect();
    const query = 'INSERT INTO public.migration (name) VALUES ($1)';
    const values = [name];
    await client.query(query, values);
    client.release();
  } catch (error) {
    // Handle the error appropriately, you can log it or throw a custom error
    throw new Error('Error updating migration table');
  }
};

const ensureSqlExists = () => {
  if (fs.existsSync('../migrations/sql')) {
    return true;
  } else {
    return false;
  }
};

function getMigrationFileName() {
  const timestamp = Date.now(); // Get current timestamp
  const uniqueIdentifier = Math.random().toString(20).substring(2, 7); // Generate a random unique identifier
  return `auto_gen-edit_collection${timestamp}_${uniqueIdentifier}.sql`;
}

function getMigrationDeatils(collectionData: Collection) {
  const migrationName = getMigrationFileName();

  const migrationContentWithUpdate = (data: any): string => {
    const {
      name,
      cover,
      display_name,
      description,
      shadowColor,
      textColor,
      path,
      ref,
    } = data;
    const colors = {
      textColor: textColor,
      shadowColor: shadowColor,
    };

    let sqlContent = '';
    const adminLine = `-- Auto-generated by an admin\n`;
    const migrationContent = `-- Migration ${'add-collection'} action on table photos.collection\n`;
    return (sqlContent = `
                ${adminLine} ${migrationContent}
                INSERT photos.collection (name, cover, display_name, colors, description, ref, path)
                VALUES (
      '${name}',
      '${cover}',
      '${display_name}',
      '${JSON.stringify(colors)}',
      '${description}',
       '${ref}',
         '${path}',

    );
           `);
  };

  // Return migration content as a string
  return {
    sqlName: migrationName,
    sqlContents: migrationContentWithUpdate(collectionData),
  };
}

// Not moved the iso because of direcory dependencies
function uploadMigration(contents: string, name: string) {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = dirname(__filename);

  const directory = path.join(__dirname, '..', '..', '..', 'migrations', 'sql');
  const where = path.join(directory, name);

  fs.writeFile(where, contents, (err) => {
    if (err) {
      console.error('Error with admin action', err);
      throw new Error('Error writing file');
    }
  });
  return where;
}

async function deleteFile(filePath: string) {
  try {
    await fs.promises.unlink(filePath);
  } catch (err) {
    console.error(`Error deleting file ${filePath}:`, err);
  }
}

export const handleAddCollection = async (data: Collection) => {
  const hasSqlDirectory = ensureSqlExists();
  const details = getMigrationDeatils(data);

  const where = uploadMigration(details.sqlContents, details.sqlName);

  //     try {
  //       await runMigration(deatils.sqlContents);
  //       await updateMigrationTable(deatils.sqlName);
  //     } catch (e) {
  //       deleteFile(where);
  //       throw new Error('Error with migration process');
  //     }
  //   } else {
  //     throw new Error('Sql directory does not exist');
  //   }
};
