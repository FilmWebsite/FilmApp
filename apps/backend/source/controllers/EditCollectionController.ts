import fs from 'fs';
import path, { dirname } from 'path';
import { fileURLToPath } from 'url';
import { pool } from '@film/postgres-api';

export const runMigration = async (migration: string) => {
  try {
    const client = await pool.connect();

    await client.query(migration);
    client.release();
  } catch (error) {
    // Handle the error appropriately, you can log it or throw a custom error
    console.log(error);
    throw new Error('Error updating migration table');
  }
};

export const updateMigrationTable = async (name: string) => {
  try {
    const client = await pool.connect();
    const query = 'INSERT INTO public.migration (name) VALUES ($1)';
    const values = [name];
    await client.query(query, values);
    client.release();
  } catch (error) {
    // Handle the error appropriately, you can log it or throw a custom error
    throw new Error('Error updating migration table');
  }
};

const ensureSqlExists = () => {
  if (fs.existsSync('../migrations/sql')) {
    return true;
  } else {
    return false;
  }
};

function getMigrationFileName() {
  const timestamp = Date.now(); // Get current timestamp
  const uniqueIdentifier = Math.random().toString(20).substring(2, 7); // Generate a random unique identifier
  return `auto_gen-edit_collection${timestamp}_${uniqueIdentifier}.sql`;
}

function getMigrationDeatils(id: string, clauses: any) {
  const migrationName = getMigrationFileName();
  const adminLine = `-- Auto-generated by an admin\n`;
  const migrationContent = `-- Migration ${'edit-collection'} action on table photos.collection\n`;

  const migrationContentWithUpdate = (clauses: any): string => {
    let sqlContent = '';
    return (sqlContent = `
                ${adminLine} ${migrationContent}
                UPDATE photos.collection
            SET ${clauses}
                WHERE id = '${id}';`);
  };

  // Return migration content as a string
  return {
    sqlName: migrationName,
    sqlContents: migrationContentWithUpdate(clauses),
  };
}

// Not moved the iso because of direcory dependencies
function uploadMigration(contents: string, name: string) {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = dirname(__filename);

  const directory = path.join(__dirname, '..', '..', '..', 'migrations', 'sql');
  const where = path.join(directory, name);

  fs.writeFile(where, contents, (err) => {
    if (err) {
      console.error('Error with admin action', err);
      throw new Error('Error writing file');
    }
  });
  return where;
}

async function deleteFile(filePath: string) {
  try {
    await fs.promises.unlink(filePath);
  } catch (err) {
    console.error(`Error deleting file ${filePath}:`, err);
  }
}

async function getCurrentColors(id: string): Promise<any> {
  const client = await pool.connect();
  try {
    const result = await client.query(
      'SELECT colors FROM photos.collection WHERE id = $1',
      [id]
    );
    client.release();
    return result.rows[0]?.colors || {};
  } catch (error) {
    client.release();
    console.error('Error fetching current colors:', error);
    throw new Error('Error fetching current colors');
  }
}

type CollectionEdits = {
  name?: string;
  textColor?: string;
  shadowColor?: string;
  description?: string;
  display_name?: string;
};
export const handleEditCollection = async (
  id: string,
  data: CollectionEdits
) => {
  const hasSqlDirectory = ensureSqlExists();

  const updateColors = async (
    id: string,
    newColors: Partial<{ textColor: string; shadowColor: string }>
  ) => {
    const currentColors = await getCurrentColors(id);
    return { ...currentColors, ...newColors };
  };

  const buildSetClauses = async () => {
    let setClauses = '';

    if (data.textColor || data.shadowColor) {
      const updatedColors = await updateColors(id, {
        textColor: data.textColor,
        shadowColor: data.shadowColor,
      });

      setClauses += `colors = '${JSON.stringify(updatedColors)}'`;
    }

    // Add other fields to the set clauses
    if (data.name)
      setClauses += `${setClauses ? ', ' : ''}name = '${data.name}'`;
    if (data.description)
      setClauses += `${setClauses ? ', ' : ''}description = '${
        data.description
      }'`;
    if (data.display_name)
      setClauses += `${setClauses ? ', ' : ''}display_name = '${
        data.display_name
      }'`;

    return setClauses;
  };

  const setClauses = await buildSetClauses();

  if (hasSqlDirectory) {
    const deatils = getMigrationDeatils(id, setClauses);

    const where = uploadMigration(deatils.sqlContents, deatils.sqlName);

    try {
      await runMigration(deatils.sqlContents);
      await updateMigrationTable(deatils.sqlName);
    } catch (e) {
      deleteFile(where);
      throw new Error('Error with migration process');
    }
  } else {
    throw new Error('Sql directory does not exist');
  }
};
